@inproceedings{abramov_combining_2000,
  title = {Combining {{Semantics}} with {{Non-standard Interpreter Hierarchies}}},
  booktitle = {{{FST TCS}} 2000: {{Foundations}} of {{Software Technology}} and {{Theoretical Computer Science}}},
  author = {Abramov, Sergei and Glück, Robert},
  editor = {Kapoor, Sanjiv and Prasad, Sanjiva},
  date = {2000},
  pages = {201--213},
  publisher = {Springer},
  location = {Berlin, Heidelberg},
  doi = {10.1007/3-540-44450-5_16},
  abstract = {This paper reports on results concerning the combination of non-standard semantics via interpreters. We define what a semantics combination means and identify under which conditions a combination can be realized by computer programs (robustness, safely combinable). We develop the underlying mathematical theory and examine the meaning of several non-standard interpreter towers. Our results suggest a technique for the implementation of a certain class of programming language dialects by composing a hierarchy of non-standard interpreters.},
  isbn = {978-3-540-44450-3},
  langid = {english}
}

@incollection{abramov_principles_2002,
  title = {Principles of {{Inverse Computation}} and the {{Universal Resolving Algorithm}}},
  booktitle = {The {{Essence}} of {{Computation}}: {{Complexity}}, {{Analysis}}, {{Transformation}}},
  author = {Abramov, Sergei and Glück, Robert},
  editor = {Mogensen, Torben Æ. and Schmidt, David A. and Sudborough, I. Hal},
  date = {2002},
  pages = {269--295},
  publisher = {Springer},
  location = {Berlin, Heidelberg},
  doi = {10.1007/3-540-36377-7_13},
  url = {https://doi.org/10.1007/3-540-36377-7_13},
  urldate = {2024-05-23},
  abstract = {We survey fundamental concepts in inverse programming and present the Universal Resolving Algorithm (URA), an algorithm for inverse computation in a first-order, functional programming language. We discuss the principles behind the algorithm, including a three-step approach based on the notion of a perfect process tree, and demonstrate our implementation with several examples. We explain the idea of a semantics modifier for inverse computation which allows us to perform inverse computation in other programming languages via interpreters.},
  isbn = {978-3-540-36377-4},
  langid = {english}
}

@article{abramov_standard_2001,
  title = {From Standard to Non-Standard Semantics by Semantics Modifiers},
  author = {Abramov, Sergei and Glück, Robert},
  date = {2001-04},
  journaltitle = {International Journal of Foundations of Computer Science},
  shortjournal = {Int. J. Found. Comput. Sci.},
  volume = {12},
  number = {02},
  pages = {171--211},
  publisher = {World Scientific Publishing Co.},
  issn = {0129-0541},
  doi = {10.1142/S0129054101000448},
  url = {https://www.worldscientific.com/doi/abs/10.1142/S0129054101000448},
  urldate = {2024-05-23},
  abstract = {An approach for systematically modifying the semantics of programming languages by semantics modifiers is described. Semantics modifiers are a class of programs that allow the development of general and reusable "semantics components". Language independence is achieved through the interpretive approach: an interpreter serves as a mediator between the new language and the language for which the non-standard semantics was implemented. Inverse computation, equivalence transformation and neighborhood analysis are shown to be semantics modifiers. Experiments with these modifiers show the computational feasibility of this approach. Seven modifier projections are given which allow the efficient implementation of non-standard interpreters and non-standard compilers by program specialization or other powerful program transformation methods.},
  keywords = {interpreters,non-standard semantics,partial evaluation,program transformation,programming languages,supercompilation}
}

@inproceedings{axelsen_simple_2011,
  title = {A {{Simple}} and {{Efficient Universal Reversible Turing Machine}}},
  booktitle = {Language and {{Automata Theory}} and {{Applications}}},
  author = {Axelsen, Holger Bock and Glück, Robert},
  editor = {Dediu, Adrian-Horia and Inenaga, Shunsuke and Martín-Vide, Carlos},
  date = {2011},
  pages = {117--128},
  publisher = {Springer},
  location = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-21254-3_8},
  abstract = {We construct a universal reversible Turing machine (URTM) from first principles. We take a strict approach to the semantics of reversible Turing machines (RTMs), under which they can compute exactly all injective, computable functions, but not non-injective ones. The natural notion of universality for RTMs is RTM-universality, where programs are considered part of both input and output of a URTM.},
  isbn = {978-3-642-21254-3},
  langid = {english}
}

@article{brown_jones-optimal_2018,
  title = {Jones-Optimal Partial Evaluation by Specialization-Safe Normalization},
  author = {Brown, Matt and Palsberg, Jens},
  date = {2018-01},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {2},
  pages = {1--28},
  issn = {2475-1421},
  doi = {10.1145/3158102},
  url = {https://dl.acm.org/doi/10.1145/3158102},
  urldate = {2024-05-23},
  abstract = {We present partial evaluation by specialization-safe normalization, a novel partial evaluation technique that is Jones-optimal, that can be self-applied to achieve the Futamura projections and that can be type-checked to ensure it always generates code with the correct type. Jones-optimality is the gold-standard for nontrivial partial evaluation and guarantees that a specializer can remove an entire layer of interpretation. We achieve Jones-optimality by using a novel affine-variable static analysis that directs specialization-safe normalization to always decrease a program’s runtime.             We demonstrate the robustness of our approach by showing Jones-optimality in a variety of settings. We have formally proved that our partial evaluator is Jones-optimal for call-by-value reduction, and we have experimentally shown that it is Jones-optimal for call-by-value, normal-order, and memoized normal-order. Each of our experiments tests Jones-optimality with three different self-interpreters.                            We implemented our partial evaluator in F               ω                                µ                 i                              , a recent language for typed self-applicable meta-programming. It is the first Jones-optimal and self-applicable partial evaluator whose type guarantees that it always generates type-correct code.},
  issue = {POPL},
  langid = {english}
}

@inproceedings{gluck_abstraction-based_2000,
  title = {Abstraction-{{Based Partial Deduction}} for {{Solving Inverse Problems}} — {{A Transformational Approach}} to {{Software Verification}}},
  booktitle = {Perspectives of {{System Informatics}}},
  author = {Glück, Robert and Leuschel, Michael},
  editor = {Bjøner, Dines and Broy, Manfred and Zamulin, Alexandre V.},
  date = {2000},
  pages = {93--100},
  publisher = {Springer},
  location = {Berlin, Heidelberg},
  doi = {10.1007/3-540-46562-6_8},
  abstract = {We present an approach to software verification by program inversion, exploiting recent progress in the field of automatic program transformation, partial deduction and abstract interpretation. Abstraction-based partial deduction can work on infinite state spaces and produce finite representations of infinite solution sets. We illustrate the potential of this approach for infinite model checking of safety properties.},
  isbn = {978-3-540-46562-1},
  langid = {english}
}

@inproceedings{gluck_jones_2002,
  title = {Jones Optimality, Binding-Time Improvements, and the Strength of Program Specializers},
  booktitle = {Proceedings of the {{ASIAN}} Symposium on {{Partial}} Evaluation and Semantics-Based Program Manipulation},
  author = {Glück, Robert},
  date = {2002-09-12},
  series = {{{ASIA-PEPM}} '02},
  pages = {9--19},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/568173.568175},
  url = {https://doi.org/10.1145/568173.568175},
  urldate = {2024-05-22},
  abstract = {Jones optimality tells us that a program specializer is strong enough to remove an entire level of self-interpretation. We show that Jones optimality, which was originally aimed at the Futamura projections, plays an important role in binding-time improvements. The main results show that, regardless of the binding-time improvements which we apply to a source program, no matter how extensively, a specializer that is not Jones-optimal is strictly weaker than a specializer which is Jones optimal. By viewing a binding-time improver as a generating extension of a self-interpreter, we can connect our results with previous work on the interpretive approach.},
  isbn = {978-1-58113-458-2},
  keywords = {binding-time improvements,Futamura projections,interpretive approach,Jones optimality,metacomputation,self-interpreters,specializer projections}
}

@article{gluck_minimalists_2017,
  title = {A {{Minimalist}}'s {{Reversible While Language}}},
  author = {Glück, Robert and Yokoyama, Tetsuo},
  date = {2017},
  journaltitle = {IEICE Transactions on Information and Systems},
  volume = {E100.D},
  number = {5},
  pages = {1026--1034},
  doi = {10.1587/transinf.2016EDP7274},
  abstract = {The paper presents a small reversible language R-CORE, a structured imperative programming language with symbolic tree-structured data (S-expressions). The language is reduced to the core of a reversible language, with a single command for reversibly updating the store, a single reversible control-flow operator, a limited number of variables, and data with a single atom and a single constructor. Despite its extreme simplicity, the language is reversibly universal, which means that it is as powerful as any reversible language can be, while it is linear-time self-interpretable, and it allows reversible programming with dynamic data structures. The four-line program inverter for R-CORE is among the shortest existing program inverters, which demonstrates the conciseness of the language. The translator to R-CORE, which is used to show the formal properties of the language, is clean and modular, and it may serve as a model for related reversible translation problems. The goal is to provide a language that is sufficiently concise for theoretical investigations. Owing to its simplicity, the language may also be used for educational purposes.},
  keywords = {program inversion,reversible programming language,reversible self-interpreter,translation,while language}
}

@article{gluck_reversible_2023-1,
  title = {Reversible Computing from a Programming Language Perspective},
  author = {Glück, Robert and Yokoyama, Tetsuo},
  date = {2023-04-10},
  journaltitle = {Theoretical Computer Science},
  shortjournal = {Theoretical Computer Science},
  volume = {953},
  pages = {113429},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2022.06.010},
  url = {https://www.sciencedirect.com/science/article/pii/S0304397522003619},
  urldate = {2024-05-23},
  abstract = {Software plays a central role in all aspects of reversible computing systems, and a variety of reversible programming languages have been developed. This presentation highlights the principles and main ideas of reversible computing viewed from a programming language perspective with a focus on clean reversible languages. They are the building material for software that can reap the benefits of reversible hardware and interesting in their own right. Reversible computing is situated within programming languages in general, and the relevant concepts are elaborated, including computability, injectivization and reversibilization. Features representative for many reversible languages are presented, such as reversible updates, reversible iterations, and access to a program's inverse semantics. Metaprogramming methods of particular importance to reversible programming, are introduced, including program inversion and inverse interpretation. Our presentation is independent of a particular language, although primarily the reversible language, Janus, will be used in examples.},
  keywords = {Compute-uncompute,Function injectivization,Inverse interpretation,Metacomputation,Program inversion,Program reversibilization,Reversible computing,Reversible programming}
}

@article{krakovsky_taking_2021-1,
  title = {Taking the Heat},
  author = {Krakovsky, Marina},
  date = {2021-05-24},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {64},
  number = {6},
  pages = {18--20},
  issn = {0001-0782},
  doi = {10.1145/3460214},
  url = {https://dl.acm.org/doi/10.1145/3460214},
  urldate = {2024-05-23},
  abstract = {Maxwell's demon and the high cost of erasure.}
}

@online{noauthor_partial_nodate,
  title = {Partial Evaluation, Self-Application and Types | {{SpringerLink}}},
  url = {https://link.springer.com/chapter/10.1007/BFb0032064},
  urldate = {2024-05-23}
}

@inproceedings{normann_partial_2024,
  title = {Partial {{Evaluation}} of {{Reversible Flowchart Programs}}},
  booktitle = {Proceedings of the 2024 {{ACM SIGPLAN International Workshop}} on {{Partial Evaluation}} and {{Program Manipulation}}},
  author = {Normann, Louis and Glück, Robert},
  date = {2024-01-11},
  series = {{{PEPM}} 2024},
  pages = {119--133},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/3635800.3636967},
  url = {https://dl.acm.org/doi/10.1145/3635800.3636967},
  urldate = {2024-05-22},
  abstract = {Flowchart languages are traditionally used to study the foundations of partial evaluation. This article presents a systematic and formal development of a method for partial evaluation of a reversible flowchart language. The results confirm that partial evaluation in this unconventional computing paradigm shows effects consistent with traditional partial evaluation. Experiments include specializing a symmetric encryption algorithm and a reversible interpreter for Bennett's reversible Turing machines. A defining feature of reversible languages is their invertibility. This study reports the first experiments composing program inversion and partial evaluation. The presented method is fully implemented. It is potentially of interest because reversible computing has found applications in areas as diverse as low-power computing, debugging, robotics, and quantum-inspired computing.},
  isbn = {9798400704871},
  keywords = {Flowchart Languages,Partial Evaluation,Program Inversion,Program Transformations,Reversible Computing}
}

@article{yokoyama_fundamentals_2016,
  title = {Fundamentals of Reversible Flowchart Languages},
  author = {Yokoyama, Tetsuo and Axelsen, Holger Bock and Glück, Robert},
  date = {2016-01-18},
  journaltitle = {Theoretical Computer Science},
  shortjournal = {Theoretical Computer Science},
  volume = {611},
  pages = {87--115},
  issn = {0304-3975},
  doi = {10.1016/j.tcs.2015.07.046},
  url = {https://www.sciencedirect.com/science/article/pii/S030439751500691X},
  urldate = {2024-05-23},
  abstract = {This paper presents the fundamentals of reversible flowcharts. Reversible flowcharts are intended to naturally represent the structure and control flow of reversible (imperative) programming languages in a simple computation model in the same way classical flowcharts do for conventional languages. Although reversible flowcharts are superficially similar to classical flowcharts, there are crucial differences: atomic steps are limited to locally invertible operations, and join points require an explicit orthogonalizing conditional expression. Despite these constraints, we show that reversible flowcharts are both expressive and robust: reversible flowcharts can simulate irreversible ones by adapting reversibilization techniques to the flowchart model. Thus, reversible flowcharts are r-Turing-complete, meaning that they can compute exactly all injective computable functions. Furthermore, structured reversible flowcharts are as expressive as unstructured ones, as shown by a reversible version of the classic Structured Program Theorem. We illustrate how reversible flowcharts can be concretized with two example programming languages, complete with syntax and semantics: a low-level unstructured language and a high-level structured language. We introduce concrete tools such as program inverters and translators for both languages, which follow the structure suggested by the flowchart model. To further illustrate the different concepts and tools brought together in this paper, we present two major worked examples: a reversible permutation-to-code algorithm attributed to Dijkstra, and a simulation scheme for reversible Turing machines. By exhibiting a wide range of uses, we hope that the proposed reversible flowcharts can serve as a springboard for further theoretical research in reversible computing.},
  keywords = {Flowchart,Program inversion,r-Turing-completeness,Reversible computing,Structured program theorem,Structured programming}
}

@inproceedings{yokoyama_reversible_2007-1,
  title = {A Reversible Programming Language and Its Invertible Self-Interpreter},
  booktitle = {Proceedings of the 2007 {{ACM SIGPLAN}} Symposium on {{Partial}} Evaluation and Semantics-Based Program Manipulation},
  author = {Yokoyama, Tetsuo and Glück, Robert},
  date = {2007-01-15},
  series = {{{PEPM}} '07},
  pages = {144--153},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/1244381.1244404},
  url = {https://doi.org/10.1145/1244381.1244404},
  urldate = {2024-05-22},
  abstract = {A reversible programming language supports deterministic forward and backward computation. We formalize the programming language Janus and prove its reversibility. We provide a program inverter for the language and implement a self-interpreter that achieves deterministic forward and backward interpretation of Janus programs without using a computation history. As the self-interpreter is implemented in a reversible language, it is invertible using local program inversion. Many physical phenomena are reversible and we demonstrate the power of Janus by implementing a reversible program for discrete simulation of the Schrödinger wave equation that can be inverted as well as run forward and backward.},
  isbn = {978-1-59593-620-2},
  keywords = {Janus,non-standard interpreter hierarchy,program inversion,reversible computing,reversible programming language,self-interpreter}
}
